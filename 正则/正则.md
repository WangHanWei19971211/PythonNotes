## 正则表达式

**正则表达式**，又称规则表达式

正则表达式(regular expression)描述了一种字符串匹配的模式（pattern）

### 一、正则匹配就是一个 模糊的匹配(不是精确匹配)

```python
1.[]		#代表原子表  存储表达式  字符集合。匹配所包含的任意一个字符
  [a]   	#匹配一个字母a  
  [abc] 	#匹配字母a/b/c
  [a-z] 	#匹配任意一位小写字母
  [AaBb] 	#匹配任意一位大小写字母a/b
  [a-zA-Z] #匹配任意一位字母
  [0-9]  	#匹配任意一位数字
  [a-zA-Z0-9] #匹配任意一位数字或字母
    	
2. ^ 		#以什么开头    在原子表外开头 以什么...开头 在原子表内 取反  相当于 \A
  [^a-z] 	#小写字母以外的字符
  ^a[a-zA-Z] #匹配 以字母a开头的俩位字母
  ^[a-zA-Z]  #以任意一位字母开头的字符
    
3. $		#以...结尾   ^和 $ 搭配来使用的  这样才能够真正的去限制你匹配的内容和长度  相当于\Z
	^1[3-8][0-9]{9}$ #匹配手机号
    ^1[38][0-9]{9}$ #匹配手机号
    
4.{m} 		#表示前面的数量m个  不能单独使用
  [a][a][a] #匹配3个a
  a{3}
  [a-zA-Z]{3} #匹配任意3位字母
  ^[a-zA-Z]{3} #匹配任意3位字母作为开头的字符串
  ^[a-zA-Z]{3}[0-9]{8}$
    
5.{m,n}    #表示前面的数量m-n个  不能单独使用
  ^[1-9][0-9]{4,10}$#匹配QQ号
    
6.{m,}		#表示前面的数量至少m个  不能单独使用

7. ?		#可有可无    匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?
  [1-9][0-9]?
  [1-9][0-9]{0,1}
  -?[1-9]  #一位整数
8. .		#匹配换行符\n以外的任意字符

9. *		#匹配前面字符任意次{0,}

10. .*		#匹配换行符以外任意字符任意次  （贪婪模式）

11. .*?		#匹配换行符以外任意字符任意次   (非贪婪模式)

12. +		#表示匹配数量 最少 1次	{1,}

13. .+		#表示匹配换行符 以外的任意字符 至少一次 （贪婪模式）

14. .+?		#表示匹配换行符 以外的任意字符 至少一次 （非贪婪模式）
    
15. ()		#1.一个单元 2.子存储
	(?:pattern) #只做为一个单元使用 而不是作为子存储
    (?=pattern) #返回不包含括号里面的值
    	re.findall("Windows(?=95|98|NT|2000)",'WindowsNT')#Windows
    (?!pattern) #与上面的相反 只要后面的不相等 就会将前面的内容匹配返回

16. |		#表示或
 
常用组合
[.*?]
[\s\S]
```

### 贪婪非贪婪

```
<H1>Chapter 1 - 介绍正则表达式</H1>
```

**贪婪：**下面的表达式匹配从开始小于符号 (<) 到关闭 H1 标记的大于符号 (>) 之间的所有内容。

```
/<.*>/
```

**非贪婪：**如果您只需要匹配开始和结束 H1 标签，下面的非贪婪表达式只匹配 <H1>。

```
/<.*?>/
```

如果只想匹配开始的 H1 标签，表达式则是：

```
/<\w+?>
```

## 二、不转成正则对象的修正符

re.I		#忽略大小写

re.M	#多行模式 改变 ^和$的行为

re.S		#改变点的行为   可以使.匹配换行符



## 三、特殊意义的字符

\d   0-9  相当于[0-9]

\D   取反  相当于\[^0-9]

\w	相当于	[a-zA-Z0-9_]

\W	取反		\[^a-zA-Z0-9_]

\s			匹配空白字符

\S			匹配非空白字符

## 四、普通字符

普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。



## 五、非打印字符

非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：

| 字符   | 描述                                       |
| ---- | ---------------------------------------- |
| \cx  | 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| \f   | 匹配一个换页符。等价于 \x0c 和 \cL。                  |
| \n   | 匹配一个换行符。等价于 \x0a 和 \cJ。                  |
| \r   | 匹配一个回车符。等价于 \x0d 和 \cM。                  |
| \s   | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 |
| \S   | 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。            |
| \t   | 匹配一个制表符。等价于 \x09 和 \cI。                  |
| \v   | 匹配一个垂直制表符。等价于 \x0b 和 \cK。                |



## 练习

```python
^[a-zA-Z0-9_]{1,}$      // 所有包含一个以上的字母、数字或下划线的字符串 
^[1-9][0-9]{0,}$        // 所有的正整数 
^\-{0,1}[0-9]{1,}$      // 所有的整数 
^[-]?[0-9]+\.?[0-9]+$   // 所有的浮点数

^[a-zA-Z0-9_]+$      // 所有包含一个以上的字母、数字或下划线的字符串 
^[1-9][0-9]*$        // 所有的正整数 
^\-?[0-9]+$          // 所有的整数 
^\-?[0-9]+\.?[0-9]*$ // 所有的浮点数
#以上正负整数浮点数的简写
^\-?[0-9]{1,}\.?[0-9]{1,}$
```



## 六、正则的函数

##### 使用正则 需要导入 re 正则模块

#### (1) re.match(正则,字符串,修正符)

匹配成功返回 匹配的对象  

使用group()方法 获取到匹配的值

groups()    返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。

匹配失败 返回 None

##### 注意：

​	从第一位开始匹配

​	只匹配一次

```python
#给当前匹配到的结果起别名
s = '3G4HFD567'
re.match("(?P<value>\d+)",s)
print(x.group(0))
print(x.group('value'))
```

#### (2) re.search(正则,字符串,修正符)

匹配成功返回 匹配的对象  使用group()方法 获取到匹配的值

匹配失败 返回 None

##### 注意：

​	只要字符串包含就可以

​	只匹配一次

#### (3) re.findall(正则,字符串,修正符)

匹配成功返回列表

##### 注意：

​	匹配多次

#### (4) re.sub/re.subn    正则的替换

sub(正则,替换成谁,字符串,替换的次数) 	返回匹配后的结果

subn(正则,替换成谁,字符串,替换的次数) 	返回匹配后的结果和次数

##### 实例

```python
import re
 
# 将匹配的数字乘于 2
def double(matched):
    value = int(matched.group('value'))
    return str(value * 2)
 
s = 'A23G4HFD567'
print(re.sub('(?P<value>\d+)', double, s))
```



#### (5) re.finditer   将查询结果变成 迭代器 的形式 返回  配合next方法来使用

​	**next()**

​	走完以后  返回 StopIteration



#### (6) re.split	   正则拆分

re.split("\W",myStr)

#### (7) preg = re.compile("1\[3-8][0-9]{9}") 

以后使用 这种方式 居多   将正则 和函数  分开  执行效率 要高

使用方法re.compile("正则","修正符")

转换的正则对象.正则的函数(字符串)\

##### 修正符的区别：

```python
re.I(IGNORECASE) #不区分大小写
re.S(DOTALL)	  #改变点的行为
re.M(MULTILINE)  #多行模式
```
